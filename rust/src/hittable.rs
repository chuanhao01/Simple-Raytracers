use std::{cmp::Ordering, fmt::Display, sync::Arc};

use rand::{thread_rng, Rng};

use crate::{ray::Ray, Hittables, Interval, Materials, Vec3};

mod bvh;
use bvh::{HittableWithBBox, AABB};

pub struct HitRecord {
    /// Point at which the hit occurs
    pub p: Vec3,
    /// t value used to generate the hit Point from the ray
    pub t: f64,
    /// Material of the Hittable Object hit
    pub material: Arc<Materials>,
    /// Unit Vector of the normal generated by the hit ray, going against the direction of the hit ray
    pub against_normal_unit: Vec3,
    /// If the ray hits from the outside
    pub front_face: bool,
}
impl HitRecord {
    /// Used to create the HitRecord object
    /// Takes in the ray that Hits the object as well as the
    pub fn new(_ray: &Ray, outward_normal_unit: &Vec3, t: f64, material: Arc<Materials>) -> Self {
        let p = _ray.at(t);
        let front_face = Vec3::dot(&_ray.direction, outward_normal_unit) < 0_f64;
        let against_normal_unit = if front_face {
            outward_normal_unit.clone()
        } else {
            -outward_normal_unit.clone()
        };
        HitRecord {
            p,
            t,
            material,
            against_normal_unit,
            front_face,
        }
    }
}

pub trait Hittable {
    fn hit(&self, _ray: &Ray, valid_t_interval: Interval) -> Option<HitRecord> {
        None
    }
}
// impl Default for Arc<dyn Hittable> {
//     fn default() -> Self {
//         Self::default()
//     }
// }

/// A Hittable List (extended with a [bvh::aabb::AABB] BBox)
/// The AABB BBox is the extended part
/// Do create the object with a default and use the [HittableList::add] method to add Hittables to the list
#[derive(Default)]
pub struct HittablesList {
    pub v: Vec<Arc<dyn HittableWithBBox>>,
    bbox: AABB,
}
impl HittablesList {
    /// Create an empty HittableList
    pub fn new() -> Self {
        Self {
            v: Vec::new(),
            bbox: AABB::default(),
        }
    }

    /// Adds a new Hittable into the list
    pub fn add(&mut self, hittable: Arc<dyn HittableWithBBox>) {
        // Dont think this is needed anywhere?
        self.bbox = AABB::from_aabb(&self.bbox, hittable.bbox());
        self.v.push(hittable);
    }
    /// Appends the hittables to the current list
    pub fn append(&mut self, hittables: &mut Vec<Arc<dyn HittableWithBBox>>) {
        self.bbox = hittables.iter().fold(self.bbox, |acc, hittable| {
            AABB::from_aabb(&acc, hittable.bbox())
        });

        self.v.append(hittables);
    }
    /// Method to get the length of Hittables
    pub fn len(&self) -> usize {
        self.v.len()
    }

    pub fn is_empty(&self) -> bool {
        self.v.is_empty()
    }
}
impl Hittable for HittablesList {
    fn hit(&self, _ray: &Ray, valid_t_interval: Interval) -> Option<HitRecord> {
        // For each hittable in the vec, iter through the hittables and run hit, accumulate the hits and return the nearest hit
        let (_, result) = self
            .v
            .iter()
            .fold((valid_t_interval.max, None), |acc, hittable| {
                if let Some(hit_record) = hittable.hit(
                    _ray,
                    Interval {
                        min: valid_t_interval.min,
                        max: acc.0,
                    },
                ) {
                    (hit_record.t, Some(hit_record))
                } else {
                    acc
                }
            });
        result
    }
}

// impl Hittable<HitRecord> for Vec<Hittables> {
//     fn hit(&self, _ray: &Ray, valid_t_interval: Interval) -> Option<HitRecord> {
//         // For each hittable in the vec, iter through the hittables and run hit, accumulate the hits and return the nearest hit
//         let (_, result) = self
//             .iter()
//             .fold((valid_t_interval.max, None), |acc, hittable| {
//                 if let Some(hit_record) = hittable.hit(
//                     _ray,
//                     Interval {
//                         min: valid_t_interval.min,
//                         max: acc.0,
//                     },
//                 ) {
//                     (hit_record.t, Some(hit_record))
//                 } else {
//                     acc
//                 }
//             });
//         result
//     }
// }
// impl Hittable<HitRecord> for Vec<Arc<Hittables>> {
//     fn hit(&self, _ray: &Ray, valid_t_interval: Interval) -> Option<HitRecord> {
//         // For each hittable in the vec, iter through the hittables and run hit, accumulate the hits and return the nearest hit
//         let (_, result) = self
//             .iter()
//             .fold((valid_t_interval.max, None), |acc, hittable| {
//                 if let Some(hit_record) = hittable.hit(
//                     _ray,
//                     Interval {
//                         min: valid_t_interval.min,
//                         max: acc.0,
//                     },
//                 ) {
//                     (hit_record.t, Some(hit_record))
//                 } else {
//                     acc
//                 }
//             });
//         result
//     }
// }

#[cfg(test)]
mod test {
    use std::f64::INFINITY;

    use crate::{Lambertain, Metal, ScatterMaterials, Sphere};

    use super::*;

    #[test]
    fn test_bvh_from_hittable_list() {
        let mut hittable_list = HittablesList::new();
        hittable_list.add(Arc::new(Hittables::Sphere(Sphere::new(
            Vec3::new_int(0, 0, 0),
            1.0,
            Arc::new(Materials::ScatterMaterial(ScatterMaterials::None)),
        ))));
        hittable_list.add(Arc::new(Hittables::None));
        hittable_list.add(Arc::new(Hittables::None));
        hittable_list.add(Arc::new(Hittables::None));

        let bvh = BVH::from_hittable_list(&hittable_list);
        // Bad Rust code, but oh well its for a test
        if let Hittables::Sphere(ref sphere) = *bvh.left.unwrap().left.unwrap().hittable.unwrap() {
            assert_eq!(sphere.radius, 1.0);
            assert!(matches!(
                *sphere.material,
                Materials::ScatterMaterial(ScatterMaterials::None)
            ))
        }
    }
    #[test]
    fn test_bvh_hit() {
        let mut hittable_list = HittablesList::new();
        hittable_list.add(Arc::new(Hittables::Sphere(Sphere::new(
            Vec3::new_int(0, 0, -1),
            0.5,
            Arc::new(Materials::ScatterMaterial(ScatterMaterials::Metal(
                Metal::new(Vec3::new(0.0, 0.0, 1.0), 0.1),
            ))),
        ))));
        hittable_list.add(Arc::new(Hittables::Sphere(Sphere::new(
            Vec3::new_int(0, 0, -3),
            1.0,
            Arc::new(Materials::ScatterMaterial(ScatterMaterials::Lambertain(
                Lambertain {
                    albedo: Vec3::new(0.0, 1.0, 0.0),
                },
            ))),
        ))));
        hittable_list.add(Arc::new(Hittables::Sphere(Sphere::new(
            Vec3::new_int(0, 0, -5),
            1.0,
            Arc::new(Materials::ScatterMaterial(ScatterMaterials::Lambertain(
                Lambertain {
                    albedo: Vec3::new(0.0, 0.0, 1.0),
                },
            ))),
        ))));
        let bvh = BVH::from_hittable_list(&hittable_list);

        let hit = bvh
            .hit(
                &Ray {
                    origin: Vec3::new_int(0, 0, 0),
                    direction: Vec3::new(0.0, 0.0, -1.0),
                },
                Interval {
                    min: 0.001,
                    max: INFINITY,
                },
            )
            .unwrap();
        assert_eq!(hit.t, 0.5);
    }
}
