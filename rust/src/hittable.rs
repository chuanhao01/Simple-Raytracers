use std::sync::Arc;

use crate::{ray::Ray, Interval, Materials, Vec3};

mod bvh;
pub use bvh::{HittableWithBBox, AABB, BVH};

pub struct HitRecord {
    /// Point at which the hit occurs
    pub p: Vec3,
    /// t value used to generate the hit Point from the ray
    pub t: f64,
    /// Material of the Hittable Object hit
    pub material: Arc<Materials>,
    /// Unit Vector of the normal generated by the hit ray, going against the direction of the hit ray
    pub against_normal_unit: Vec3,
    /// If the ray hits from the outside
    pub front_face: bool,
}
impl HitRecord {
    /// Used to create the HitRecord object
    /// Takes in the ray that Hits the object as well as the
    pub fn new(_ray: &Ray, outward_normal_unit: &Vec3, t: f64, material: Arc<Materials>) -> Self {
        let p = _ray.at(t);
        let front_face = Vec3::dot(&_ray.direction, outward_normal_unit) < 0_f64;
        let against_normal_unit = if front_face {
            outward_normal_unit.clone()
        } else {
            -outward_normal_unit.clone()
        };
        HitRecord {
            p,
            t,
            material,
            against_normal_unit,
            front_face,
        }
    }
}

pub trait Hittable: Sync + Send {
    #[allow(unused_variables)]
    fn hit(&self, ray: &Ray, valid_t_interval: Interval) -> Option<HitRecord> {
        None
    }
}

/// A Hittable List (extended with a [bvh::aabb::AABB] BBox)
/// Think of as a wrapper for a larger object composed of object primitives (Could also just use a BVH)
///
/// The reason why we cannot use a Vec<Arc<dyn HittableWithBBox>> is because we would need to implement HittableWithBBox on it (which is what this struct does)
#[derive(Default)]
pub struct HittablesList {
    pub v: Vec<Arc<dyn HittableWithBBox>>,
    bbox: AABB,
}
impl HittablesList {
    /// Create an empty HittableList
    pub fn new() -> Self {
        Self {
            v: Vec::new(),
            bbox: AABB::default(),
        }
    }

    /// Adds a new Hittable into the list
    pub fn add(&mut self, hittable: Arc<dyn HittableWithBBox>) {
        // Dont think this is needed anywhere?
        self.bbox = AABB::from_aabb(&self.bbox, hittable.bbox());
        self.v.push(hittable);
    }
    /// Appends the hittables to the current list
    pub fn append(&mut self, hittables: &mut Vec<Arc<dyn HittableWithBBox>>) {
        self.bbox = hittables.iter().fold(self.bbox, |acc, hittable| {
            AABB::from_aabb(&acc, hittable.bbox())
        });

        self.v.append(hittables);
    }
    /// Method to get the length of Hittables
    pub fn len(&self) -> usize {
        self.v.len()
    }

    pub fn is_empty(&self) -> bool {
        self.v.is_empty()
    }
}
impl Hittable for HittablesList {
    fn hit(&self, _ray: &Ray, valid_t_interval: Interval) -> Option<HitRecord> {
        // For each hittable in the vec, iter through the hittables and run hit, accumulate the hits and return the nearest hit
        let (_, result) = self
            .v
            .iter()
            .fold((valid_t_interval.max, None), |acc, hittable| {
                if let Some(hit_record) = hittable.hit(
                    _ray,
                    Interval {
                        min: valid_t_interval.min,
                        max: acc.0,
                    },
                ) {
                    (hit_record.t, Some(hit_record))
                } else {
                    acc
                }
            });
        result
    }
}
impl HittableWithBBox for HittablesList {
    fn bbox(&self) -> &AABB {
        &self.bbox
    }
}

impl Hittable for Vec<Arc<dyn Hittable>> {
    fn hit(&self, _ray: &Ray, valid_t_interval: Interval) -> Option<HitRecord> {
        // For each hittable in the vec, iter through the hittables and run hit, accumulate the hits and return the nearest hit
        let (_, result) = self
            .iter()
            .fold((valid_t_interval.max, None), |acc, hittable| {
                if let Some(hit_record) = hittable.hit(
                    _ray,
                    Interval {
                        min: valid_t_interval.min,
                        max: acc.0,
                    },
                ) {
                    (hit_record.t, Some(hit_record))
                } else {
                    acc
                }
            });
        result
    }
}
