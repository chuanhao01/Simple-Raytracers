use std::sync::Arc;

use crate::{ray::Ray, Hittables, Interval, Materials, Vec3};

pub struct HitRecord {
    /// Point at which the hit occurs
    pub p: Vec3,
    /// t value used to generate the hit Point from the ray
    pub t: f64,
    /// Material of the Hittable Object hit
    pub material: Arc<Materials>,
    /// Unit Vector of the normal generated by the hit ray, going against the direction of the hit ray
    pub against_normal_unit: Vec3,
    /// If the ray hits from the outside
    pub front_face: bool,
}

impl HitRecord {
    /// Used to create the HitRecord object
    /// Takes in the ray that Hits the object as well as the
    pub fn new(_ray: &Ray, outward_normal_unit: &Vec3, t: f64, material: Arc<Materials>) -> Self {
        let p = _ray.at(t);
        let front_face = Vec3::dot(&_ray.direction, outward_normal_unit) < 0_f64;
        let against_normal_unit = if front_face {
            outward_normal_unit.clone()
        } else {
            -outward_normal_unit.clone()
        };
        HitRecord {
            p,
            t,
            material,
            against_normal_unit,
            front_face,
        }
    }
}

pub trait Hittable {
    fn hit(&self, _ray: &Ray, valid_t_interval: Interval) -> Option<HitRecord>;
}

impl Hittable for Vec<Hittables> {
    fn hit(&self, _ray: &Ray, valid_t_interval: Interval) -> Option<HitRecord> {
        // For each hittable in the vec, iter through the hittables and run hit, accumulate the hits and return the nearest Scattered
        let (_, result) = self
            .iter()
            .fold((valid_t_interval.r, None), |acc, hittable| {
                if let Some(hit_record) = hittable.hit(
                    _ray,
                    Interval {
                        l: valid_t_interval.l,
                        r: acc.0,
                    },
                ) {
                    (hit_record.t, Some(hit_record))
                } else {
                    acc
                }
            });
        result

        // let mut max_interval_r = valid_t_interval.r;
        // let mut acc = None;
        // for hittable in self {
        //     if let Some(scattered) =  hittable.hit(
        //         _ray,
        //         Interval {
        //             l: valid_t_interval.l,
        //             r: max_interval_r,
        //         },
        //     ) {
        //         max_interval_r = scattered.t;
        //         acc = Some(scattered)
        //     }
        // }
        // acc
    }
}
