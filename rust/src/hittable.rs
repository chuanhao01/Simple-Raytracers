use std::{cmp::Ordering, sync::Arc};

use rand::{thread_rng, Rng};

use crate::{objects::AABB, ray::Ray, Hittables, Interval, Materials, Vec3};

pub struct HitRecord {
    /// Point at which the hit occurs
    pub p: Vec3,
    /// t value used to generate the hit Point from the ray
    pub t: f64,
    /// Material of the Hittable Object hit
    pub material: Arc<Materials>,
    /// Unit Vector of the normal generated by the hit ray, going against the direction of the hit ray
    pub against_normal_unit: Vec3,
    /// If the ray hits from the outside
    pub front_face: bool,
}

impl HitRecord {
    /// Used to create the HitRecord object
    /// Takes in the ray that Hits the object as well as the
    pub fn new(_ray: &Ray, outward_normal_unit: &Vec3, t: f64, material: Arc<Materials>) -> Self {
        let p = _ray.at(t);
        let front_face = Vec3::dot(&_ray.direction, outward_normal_unit) < 0_f64;
        let against_normal_unit = if front_face {
            outward_normal_unit.clone()
        } else {
            -outward_normal_unit.clone()
        };
        HitRecord {
            p,
            t,
            material,
            against_normal_unit,
            front_face,
        }
    }
}

pub trait Hittable<T> {
    fn hit(&self, _ray: &Ray, valid_t_interval: Interval) -> Option<T>;
}

/// A Hittable List to hold all the Hittables in the world
/// Do create the object with a default and use the [HittableList::add] method to add Hittables to the list
#[derive(Default)]
pub struct HittableList {
    v: Vec<Arc<Hittables>>,
    bbox: AABB,
}
impl HittableList {
    /// Adds a new Hittable into the list
    pub fn add(mut self, hittable: Hittables) {
        self.bbox = AABB::from_aabb(&self.bbox, hittable.bbox());
        self.v.push(Arc::new(hittable));
    }
    /// Method to get the length of Hittables
    pub fn len(self) -> usize {
        self.v.len()
    }
}

/// Bounding volume hierarchy
pub struct BVH {
    left: Option<Arc<BVH>>,
    right: Option<Arc<BVH>>,
    bbox: AABB,
    hittable: Option<Arc<Hittables>>,
}
impl BVH {
    pub fn from_hittable_list(hittable_list: &HittableList) -> Self {
        Self::new(hittable_list, 0, hittable_list.len())
    }
    fn new(hittable_list: &HittableList, start: usize, end: usize) -> Self {
        let mut rng = thread_rng();
        let axis = rng.gen_range(0_i64..3_i64);

        let hittable_comparer = |a: &Arc<Hittables>, b: &Arc<Hittables>| -> Ordering {
            if a.bbox().axis(axis).min < b.bbox().axis(axis).min {
                Ordering::Less
            } else if a.bbox().axis(axis).min > b.bbox().axis(axis).min {
                Ordering::Greater
            } else {
                Ordering::Equal
            }
        };
        let list_size = end - start;
        if list_size == 0 {
            BVH {
                left: None,
                right: None,
                hittable: Some(Arc::new(Hittables::None)),
                bbox: Hittables::None.bbox().clone(),
            }
        } else if list_size == 1 {
            BVH {
                left: None,
                right: None,
                hittable: Some(hittable_list.v[start]),
                bbox: hittable_list.v[start].bbox().clone(),
            }
        } else if list_size == 2 {
            BVH {
                left: Some(Arc::new(BVH {
                    left: None,
                    right: None,
                    hittable: Some(hittable_list.v[start]),
                    bbox: hittable_list.v[start].bbox().clone(),
                })),
                right: Some(Arc::new(BVH {
                    left: None,
                    right: None,
                    hittable: Some(hittable_list.v[end - 1]),
                    bbox: hittable_list.v[end - 1].bbox().clone(),
                })),
                hittable: None,
                bbox: AABB::from_aabb(hittable_list.v[start].bbox(), hittable_list.v[end - 1].bbox())
            }
        } else {
            BVH {
                left: None,
                right: None,
                hittable: Some(hittable_list.v[start]),
                bbox: hittable_list.v[start].bbox().clone(),
            }
        }
        // let (left, right) = if list_size == 1{
        //     // (hittable_list.v[start], hittable_list.v[start])
        // } else if list_size == 2 {
        //     (hittable_list.v[start], hittable_list.v[end])
        // } else if list_size == 3 {
        //     (BVH::new(hittable_list, start, start+1), hittable_list.v[end])
        // } else {
        //     let hittable_list = hittable_list.v.clone().sort_by(hittable_comparer);
        //     let mid = start + list_size / 2;
        //     (BVH::new(hittable_list, start, mid), BVH::new(hittable_list, mid, end))
        // }
    }
}

impl Hittable<HitRecord> for Vec<Hittables> {
    fn hit(&self, _ray: &Ray, valid_t_interval: Interval) -> Option<HitRecord> {
        // For each hittable in the vec, iter through the hittables and run hit, accumulate the hits and return the nearest Scattered
        let (_, result) = self
            .iter()
            .fold((valid_t_interval.max, None), |acc, hittable| {
                if let Some(hit_record) = hittable.hit(
                    _ray,
                    Interval {
                        min: valid_t_interval.min,
                        max: acc.0,
                    },
                ) {
                    (hit_record.t, Some(hit_record))
                } else {
                    acc
                }
            });
        result
    }
}
